# 知识库扩展功能实现计划

## 目标

为 AiVista 后端知识库系统添加完整的 CRUD 操作支持，重点实现删除和编辑功能，同时保护默认的5个系统知识库不被误删或修改。

## 功能需求分析

### 当前现状

- ✅ 已实现：查询所有风格 (`GET /api/knowledge/styles`)
- ✅ 已实现：查询单个风格 (`GET /api/knowledge/styles/:id`)
- ✅ 已实现：向量检索 (`GET /api/knowledge/search`)
- ✅ 已实现：添加新风格 (`POST /api/knowledge/styles`)
- ❌ 待实现：删除风格功能
- ❌ 待实现：编辑风格功能
- ❌ 待实现：系统知识库保护机制

### 目标功能

1. **删除功能**：支持单个删除和批量删除
2. **编辑功能**：支持 PUT 完整更新和 PATCH 部分更新
3. **保护机制**：5个默认知识库（Cyberpunk、Watercolor、Minimalist、Oil Painting、Anime）完全只读
4. **向后兼容**：现有 API 和功能不受影响

## 详细实现计划

### 阶段1：数据模型和类型定义扩展

#### 1.1 创建 DTO 类

**文件：** `src/knowledge/dto/update-style.dto.ts`

```typescript
import { IsOptional, IsString, IsArray, IsObject } from 'class-validator';
import { Type } from 'class-transformer';

/**
 * 更新风格 DTO
 * 支持部分更新，所有字段都是可选的
 */
export class UpdateStyleDto {
  @IsOptional()
  @IsString()
  style?: string;

  @IsOptional() 
  @IsString()
  prompt?: string;

  @IsOptional()
  @IsString()
  description?: string;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @IsOptional()
  @IsObject()
  metadata?: Record<string, any>;
}
```

**文件：** `src/knowledge/dto/delete-styles.dto.ts`

```typescript
import { IsArray, IsString } from 'class-validator';

/**
 * 批量删除风格 DTO
 * 用于批量删除多个风格
 */
export class DeleteStylesDto {
  @IsArray()
  @IsString({ each: true })
  ids: string[];
}
```

#### 1.2 扩展数据模型

**文件：** `src/knowledge/interfaces/style-data.interface.ts`

```typescript
export interface StyleData {
  id: string;
  style: string;
  prompt: string;
  description?: string;
  tags?: string[];
  metadata?: Record<string, any>;
  // 新增字段
  isSystem?: boolean;  // 标记是否为系统内置
  createdAt?: Date;
  updatedAt?: Date;
  vector?: number[];   // 向量数据（内部使用）
}
```

#### 1.3 更新初始化数据

**文件：** `src/knowledge/data/initial-styles.ts`

```typescript
export const INITIAL_STYLES: StyleData[] = [
  {
    id: 'style_001',
    style: 'Cyberpunk',
    prompt: 'neon lights, high tech, low life, dark city background, futuristic, cyberpunk aesthetic, vibrant colors, urban decay',
    description: '赛博朋克风格：霓虹灯、高科技、低生活、未来主义城市背景',
    tags: ['cyberpunk', 'futuristic', 'neon', 'urban', 'sci-fi'],
    metadata: {
      category: 'digital',
      popularity: 85,
    },
    isSystem: true,  // 系统内置标记
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-01-01'),
  },
  // ... 其他4个默认样式，都设置 isSystem: true
];
```

### 阶段2：服务层业务逻辑扩展

#### 2.1 扩展 KnowledgeService

**文件：** `src/knowledge/knowledge.service.ts`

**新增方法：**

```typescript
/**
 * 删除单个风格
 * @param id 风格ID
 * @throws ForbiddenException 如果是系统内置风格
 */
async deleteStyle(id: string): Promise<void> {
  // 检查是否为系统内置
  if (await this.isSystemStyle(id)) {
    throw new ForbiddenException('Cannot delete system built-in style');
  }
  
  // 从数据库删除
  await this.table.delete(`id = '${id}'`);
  this.logger.log(`Deleted style: ${id}`);
}

/**
 * 批量删除风格
 * @param ids 风格ID数组
 */
async deleteStyles(ids: string[]): Promise<{ deleted: number; failed: string[] }> {
  const deleted: string[] = [];
  const failed: string[] = [];

  for (const id of ids) {
    try {
      await this.deleteStyle(id);
      deleted.push(id);
    } catch (error) {
      failed.push(id);
      this.logger.warn(`Failed to delete style ${id}: ${error.message}`);
    }
  }

  return { deleted: deleted.length, failed };
}

/**
 * 更新单个风格
 * @param id 风格ID
 * @param updateData 更新数据
 * @throws ForbiddenException 如果是系统内置风格且尝试修改核心字段
 */
async updateStyle(id: string, updateData: UpdateStyleDto): Promise<StyleData> {
  // 获取现有数据
  const existingStyles = await this.table.search()
    .where(`id = '${id}'`)
    .toArray();
  
  if (existingStyles.length === 0) {
    throw new NotFoundException(`Style with id ${id} not found`);
  }

  const existing = existingStyles[0];
  const isSystem = existing.isSystem || false;

  // 系统内置样式保护检查
  if (isSystem) {
    // 只允许更新 description、tags、metadata 字段
    const allowedFields = ['description', 'tags', 'metadata'];
    const restrictedFields = Object.keys(updateData).filter(
      key => !allowedFields.includes(key)
    );
    
    if (restrictedFields.length > 0) {
      throw new ForbiddenException(
        `Cannot modify system style fields: ${restrictedFields.join(', ')}`
      );
    }
  }

  // 检查 prompt 是否变化，如果变化需要重新计算向量
  let newVector = existing.vector;
  if (updateData.prompt && updateData.prompt !== existing.prompt) {
    const text = `${updateData.style || existing.style} ${updateData.prompt} ${updateData.description || existing.description || ''}`;
    newVector = await this.embeddingService.embed(text);
  }

  // 执行更新
  const updatedData = {
    ...existing,
    ...updateData,
    vector: newVector,
    updatedAt: new Date(),
  };

  // LanceDB 更新操作
  await this.table.update([updatedData]);
  this.logger.log(`Updated style: ${id}`);
  
  return updatedData;
}

/**
 * 检查是否为系统内置风格
 * @param id 风格ID
 */
private async isSystemStyle(id: string): Promise<boolean> {
  const systemIds = ['style_001', 'style_002', 'style_003', 'style_004', 'style_005'];
  
  // 首先检查是否在系统ID列表中
  if (systemIds.includes(id)) {
    return true;
  }
  
  // 然后检查数据库中的 isSystem 标记
  try {
    const styles = await this.table.search()
      .where(`id = '${id}'`)
      .select(['isSystem'])
      .toArray();
    
    return styles.length > 0 && styles[0].isSystem === true;
  } catch (error) {
    this.logger.warn(`Failed to check system status for style ${id}: ${error.message}`);
    return false;
  }
}

/**
 * 数据库迁移：为现有数据添加系统标记
 */
private async migrateDatabase(): Promise<void> {
  if (!this.table) {
    this.logger.warn('Table not initialized, skipping migration');
    return;
  }

  try {
    // 获取所有现有数据
    const searchResult = this.table.search();
    const allStyles = await searchResult.toArray();
    
    if (!allStyles || allStyles.length ===0) {
      this.logger.log('No existing data to migrate');
      return;
    }

    // 识别系统内置样式
    const systemIds = ['style_001', 'style_002', 'style_003', 'style_004', 'style_005'];
    
    // 批量更新
    const updates = allStyles.map(style => {
      const isSystem = systemIds.includes(style.id);
      return {
        ...style,
        isSystem,
        createdAt: style.createdAt || new Date('2024-01-01'),
        updatedAt: new Date(),
      };
    });

    if (updates.length > 0) {
      await this.table.update(updates);
      this.logger.log(`Database migration completed: ${updates.length} styles updated`);
    }
  } catch (error) {
    this.logger.error('Database migration failed', error);
    // 不抛出错误，避免阻止服务启动
  }
}
```

#### 2.2 修改初始化逻辑

**文件：** `src/knowledge/knowledge.service.ts`

```typescript
async onModuleInit() {
  await this.initialize();
  
  // 执行数据库迁移
  await this.migrateDatabase();
}
```

### 阶段3：控制器层 API 扩展

#### 3.1 扩展 KnowledgeController

**文件：** `src/knowledge/knowledge.controller.ts`

```typescript
import { 
  Controller, 
  Get, 
  Post, 
  Put, 
  Patch, 
  Delete, 
  Param, 
  Query, 
  Body, 
  Logger,
  HttpCode,
  HttpStatus,
  UsePipes
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiParam, ApiBody } from '@nestjs/swagger';
import { UpdateStyleDto } from './dto/update-style.dto';
import { DeleteStylesDto } from './dto/delete-styles.dto';
import { ValidationPipe } from '@nestjs/common';

// 新增 DTO 类
class BatchDeleteResponseDto {
  @ApiProperty({ description: '成功删除的数量', example: 2 })
  deleted: number;

  @ApiProperty({ description: '删除失败的ID列表', example: ['style_001', 'style_002'] })
  failed: string[];
}

// 添加验证装饰器的 AddStyleRequestDto
class AddStyleRequestDto {
  @ApiProperty({ description: '风格 ID', example: 'style_006' })
  @IsString()
  id: string;

  @ApiProperty({ description: '风格名称', example: 'Impressionist' })
  @IsString()
  style: string;

  @ApiProperty({ description: '风格提示词', example: 'impressionist painting, soft brushstrokes...' })
  @IsString()
  prompt: string;

  @ApiProperty({ description: '风格描述', required: false })
  @IsOptional()
  @IsString()
  description?: string;

  @ApiProperty({ description: '标签列表', required: false })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @ApiProperty({ description: '元数据', required: false })
  @IsOptional()
  @IsObject()
  metadata?: Record<string, any>;
}
```

**新增 RESTful 端点：**

```typescript
@Put('styles/:id')
@UsePipes(new ValidationPipe({ transform: true }))
@HttpCode(HttpStatus.NO_CONTENT)
@ApiOperation({ summary: '完全更新风格' })
@ApiParam({ name: 'id', description: '风格ID' })
@ApiBody({ type: UpdateStyleDto })
@ApiResponse({ status: 204, description: '更新成功' })
@ApiResponse({ status: 404, description: '风格不存在' })
@ApiResponse({ status: 403, description: '不能修改系统内置风格' })
async updateStyle(
  @Param('id') id: string, 
  @Body() updateDto: UpdateStyleDto
): Promise<void> {
  this.logger.log(`Updating style: ${id}`);
  await this.knowledgeService.updateStyle(id, updateDto);
}

@Patch('styles/:id')
@UsePipes(new ValidationPipe({ transform: true }))
@HttpCode(HttpStatus.NO_CONTENT)
@ApiOperation({ summary: '部分更新风格' })
@ApiParam({ name: 'id', description: '风格ID' })
@ApiBody({ type: UpdateStyleDto })
@ApiResponse({ status: 204, description: '更新成功' })
@ApiResponse({ status: 404, description: '风格不存在' })
@ApiResponse({ status: 403, description: '不能修改系统内置风格' })
async patchStyle(
  @Param('id') id: string, 
  @Body() updateDto: UpdateStyleDto
): Promise<void> {
  this.logger.log(`Patching style: ${id}`);
  await this.knowledgeService.updateStyle(id, updateDto);
}

@Delete('styles/:id')
@HttpCode(HttpStatus.NO_CONTENT)
@ApiOperation({ summary: '删除单个风格' })
@ApiParam({ name: 'id', description: '风格ID' })
@ApiResponse({ status: 204, description: '删除成功' })
@ApiResponse({ status: 404, description: '风格不存在' })
@ApiResponse({ status: 403, description: '不能删除系统内置风格' })
async deleteStyle(@Param('id') id: string): Promise<void> {
  this.logger.log(`Deleting style: ${id}`);
  await this.knowledgeService.deleteStyle(id);
}

@Post('styles/batch-delete')
@UsePipes(new ValidationPipe({ transform: true }))
@HttpCode(HttpStatus.OK)
@ApiOperation({ summary: '批量删除风格' })
@ApiBody({ type: DeleteStylesDto })
@ApiResponse({ status: 200, description: '批量删除结果', type: BatchDeleteResponseDto })
async deleteStyles(@Body() deleteDto: DeleteStylesDto): Promise<BatchDeleteResponseDto> {
  this.logger.log(`Batch deleting ${deleteDto.ids.length} styles`);
  const result = await this.knowledgeService.deleteStyles(deleteDto.ids);
  return result;
}
```

### 阶段4：测试用例实现

#### 4.1 单元测试

**文件：** `src/knowledge/knowledge.service.spec.ts`

```typescript
describe('KnowledgeService - CRUD Operations', () => {
  describe('deleteStyle', () => {
    it('should delete custom style successfully', async () => {
      // 模拟自定义样式删除
      jest.spyOn(service as any, 'isSystemStyle').mockResolvedValue(false);
      mockTable.delete.mockResolvedValue(undefined);

      await expect(service.deleteStyle('custom_001')).resolves.not.toThrow();
      expect(mockTable.delete).toHaveBeenCalledWith(`id = 'custom_001'`);
    });

    it('should throw error when trying to delete system style', async () => {
      // 模拟系统样式
      jest.spyOn(service as any, 'isSystemStyle').mockResolvedValue(true);

      await expect(service.deleteStyle('style_001')).rejects.toThrow(ForbiddenException);
      expect(mockTable.delete).not.toHaveBeenCalled();
    });
  });

  describe('updateStyle', () => {
    it('should update custom style successfully', async () => {
      const updateData: UpdateStyleDto = {
        description: 'Updated description',
        tags: ['updated', 'tag'],
      };

      // 模拟现有样式检索
      mockTable.search.mockReturnValue({
        where: jest.fn().mockReturnValue({
          toArray: jest.fn().mockResolvedValue([existingStyle]),
        }),
      });

      const result = await service.updateStyle('custom_001', updateData);
      
      expect(result.description).toBe(updateData.description);
      expect(result.tags).toEqual(updateData.tags);
    });

    it('should reject updating system style core fields', async () => {
      const updateData: UpdateStyleDto = {
        style: 'Hacked Style',
        prompt: 'Hacked prompt',
      };

      await expect(service.updateStyle('style_001', updateData))
        .rejects.toThrow(ForbiddenException);
    });
  });
});
```

#### 4.2 集成测试

**文件：** `src/knowledge/knowledge.controller.e2e-spec.ts`

```typescript
describe('KnowledgeController (e2e)', () => {
  describe('DELETE /api/knowledge/styles/:id', () => {
    it('should return 204 for successful deletion', async () => {
      jest.spyOn(knowledgeService, 'deleteStyle').mockResolvedValue(undefined);

      return request(app.getHttpServer())
        .delete('/api/knowledge/styles/custom_001')
        .expect(204);
    });

    it('should return 403 for system style deletion', async () => {
      jest.spyOn(knowledgeService, 'deleteStyle').mockRejectedValue(
        new Error('Cannot delete system built-in style')
      );

      return request(app.getHttpServer())
        .delete('/api/knowledge/styles/style_001')
        .expect(500);
    });
  });

  describe('POST /api/knowledge/styles/batch-delete', () => {
    it('should handle batch deletion properly', async () => {
      jest.spyOn(knowledgeService, 'deleteStyles').mockResolvedValue({
        deleted: 2,
        failed: ['style_001'],
      });

      return request(app.getHttpServer())
        .post('/api/knowledge/styles/batch-delete')
        .send({ ids: ['custom_001', 'custom_002', 'style_001'] })
        .expect(200)
        .expect((res) => {
          expect(res.body.deleted).toBe(2);
          expect(res.body.failed).toEqual(['style_001']);
        });
    });
  });
});
```

## 实施顺序

### 第1天：数据模型和 DTO

1. 创建 `UpdateStyleDto` 和 `DeleteStylesDto`
2. 扩展 `StyleData` 接口
3. 更新初始数据文件

### 第2天：服务层实现

1. 实现 `deleteStyle` 方法
2. 实现 `deleteStyles` 方法
3. 实现 `updateStyle` 方法
4. 实现系统保护逻辑
5. 添加数据库迁移逻辑

### 第3天：控制器层实现

1. 添加 PUT/PATCH/DELETE 端点
2. 添加批量删除端点
3. 完善 Swagger 文档注解
4. 错误处理和响应格式

### 第4天：测试和验证

1. 编写单元测试
2. 编写集成测试
3. 运行完整测试套件
4. 性能测试和优化

### 第5天：文档和部署

1. 更新 API 文档
2. 验证向后兼容性
3. 部署到测试环境
4. 准备生产环境部署

## 风险评估

### 技术风险

- **LanceDB 版本兼容性**：确保新的更新操作与当前 LanceDB 版本兼容
- **向量计算一致性**：更新 prompt 时确保向量重新计算正确
- **并发操作安全性**：批量操作时的事务处理

### 业务风险

- **数据丢失风险**：删除操作的不可逆性
- **性能影响**：向量重新计算可能影响性能
- **向后兼容性**：确保现有 API 调用不受影响

### 缓解措施

- 完整的单元测试和集成测试覆盖
- 数据库备份机制
- 渐进式部署策略
- 详细的日志记录和监控

## 验收标准

1. ✅ 所有新增 API 端点正常工作
2. ✅ 5个系统内置风格完全保护
3. ✅ 批量操作正确处理成功和失败情况
4. ✅ 向量检索功能正常（更新后）
5. ✅ 现有功能不受影响
6. ✅ 测试覆盖率 > 90%
7. ✅ API 文档完整准确
8. ✅ 性能指标满足要求

## 后续扩展

完成当前功能后，可以考虑的扩展方向：

1. **权限系统**：基于角色的访问控制
2. **版本管理**：知识库变更历史追踪
3. **导入导出**：批量数据迁移工具
4. **缓存优化**：Redis 缓存提升性能
5. **审计日志**：完整的操作记录系统

这个计划确保了功能的完整性、安全性和可维护性，同时保持了与现有系统的兼容性。